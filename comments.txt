// This file holds the main code for plugins. Code in this file has access to
// the *figma document* via the figma global object.
// You can access browser APIs in the <script> tag inside "ui.html" which has a
// full browser environment (See https://www.figma.com/plugin-docs/how-plugins-run).

// Runs this code if the plugin is run in Figma

// Calls to "parent.postMessage" from within the HTML page will trigger this
  // callback. The callback will be passed the "pluginMessage" property of the
  // posted message.

 /*const nodes: SceneNode[] = [];
      for (let i = 0; i < msg.count; i++) {
        const rect = figma.createRectangle();
        rect.x = i * 150;
        rect.fills = [{type: 'SOLID', color: {r: 1, g: 0.5, b: 0}}];
        figma.currentPage.appendChild(rect);
        nodes.push(rect);
      }
      figma.currentPage.selection = nodes;
      figma.viewport.scrollAndZoomIntoView(nodes);*/

 // Make sure to close the plugin when you're done. Otherwise the plugin will
    // keep running, which shows the cancel button at the bottom of the screen.


// Runs this code if the plugin is run in FigJam


<script src=" https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js "></script>

  async function savePng() {
    if (figma.currentPage.selection.length == 0) {
      document.getElementById('popup-save').style.display = 'block'
      // figma.ui.postMessage({ type: 'cant-save' }, { origin: "*" })
    }
    else {
      const imageBytes = await figma.currentPage.selection[0].exportAsync({ format: 'PNG' })
      const imageBlob = new Blob([imageBytes], { type: 'image/png' })
      saveAs(imageBlob, 'file-name.png')
    }
  }

// if (msg.type === 'save') {

    //   if (figma.currentPage.selection.length == 0) {
    //     figma.ui.postMessage({ type: 'cant-save' }, { origin: "*" })
    //   }
    //   else {
    //     const imageBytes = await figma.currentPage.selection[0].exportAsync({ format: 'PNG' })
    //     const imageBlob = new Blob([imageBytes], { type: 'image/png' })
    //     saveAs(imageBlob, 'file-name.png')
    //   }
    // }

    <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js" crossorigin></script>

<script>
  async function savePng() {
    if (figma.currentPage.selection.length == 0) {
      document.getElementById('popup-save').style.display = 'block'
      // figma.ui.postMessage({ type: 'cant-save' }, { origin: "*" })
    }
    else {
      const imageBytes = await figma.currentPage.selection[0].exportAsync({ format: 'PNG' })
      const imageBlob = new Blob([imageBytes], { type: 'image/png' })
      saveAs(imageBlob, 'file-name.png')
    }
  }

 function saveAs(blob, filename) {
    // Create an anchor element
    let elem = window.document.createElement('a');

    // Set the anchor element's href attribute to a URL representing the Blob object
    elem.href = window.URL.createObjectURL(blob);

    // Set the anchor element's download attribute to the desired file name
    elem.download = filename;

    // Optional: Set some styles to hide the anchor element
    // elem.setAttribute('style', 'display:none;opacity:0;color:transparent;')

    // Append the anchor element to the body of the current document
    (document.body || document.documentElement).appendChild(elem);

    // If the anchor element has a click function, call it
    if (typeof elem.click === 'function') {
      elem.click();
    }
    // If not, dispatch a mouse event with the type 'click'
    else {
      elem.target = '_blank';
      elem.dispatchEvent(new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true
      }));
    }

    // Revoke the object URL created earlier
    URL.revokeObjectURL(elem.href);

    /* Once the object URL is no longer needed, it is a good idea to revoke it to avoid using up
    unnecessary memory and resources. This is especially important in situations where you are 
    creating and revoking many object URLs in a short period of time, as is the case in this code. */

  }

   // if(figma.currentPage.children.includes(comps[i]))
    // {

    //   // figma.currentPage.children.
    // }


          // console.log(comps.length)
          //comp.name= comps.length.toString();
          //figma.currentPage.appendChild(comp);

.figma-light body {
    background-color: white;
    color: blue;
  }
  
  .figma-dark body {
    background-color: black;
    color: red;
  }

  // ef.type='LAYER-BLUR'
      // ef.type = 
      // figma.currentPage.selection[0].
      // let layers = figma.currentPage.selection
      // figma.createEffectStyle

  
/*export const invertImage = async (node: ImagePaint) => {
      const newFills = [];
    
      const image = figma.getImageByHash(node.imageHash);
      const bytes = await image.getBytesAsync();
    
      figma.showUI(__html__, { visible: false });
    
      figma.ui.postMessage({ type: 'invert-image', data: { bytes } });
    
      const newBytes: Uint8Array = await new Promise((resolve) => {
        figma.ui.onmessage = (
          message: MessageEvent & { data: { bytes: Uint8Array } }
        ) => {
          // console.log({ message });
          if (message.type === 'invert-image') {
            resolve(message.data.bytes);
          }
        };
      });
    
      const newPaint = JSON.parse(JSON.stringify(node));
    
      newPaint.imageHash = figma.createImage(newBytes).hash;
      newFills.push(newPaint);
    
      return newFills;
    };*/

// let color :RGB = {r:fill.gradientTransform[0][0], g:fill.gradientTransform[0][1], b:fill.gradientTransform[0][2]}
// let color2: RGB = { r: fill.gradientTransform[1][0], g: fill.gradientTransform[1][1], b: fill.gradientTransform[1][2] }
// let color: RGB = { r: fill.gradientStops[1].color.r, g: fill.gradientTransform[0][1], b: fill.gradientTransform[0][2] }
                   
  // }
              //  if (child.type === 'ELLIPSE' || child.type === 'LINE'
              //    || child.type === 'POLYGON' || child.type === 'STAR' || child.type === 'TEXT') {
              //     child.fills

              // }

  // if (child.type === 'VECTOR') {
              //   const fills = clone(child.fills);
                // fills.forEach((fill) => {
                //   if (fill.type === 'SOLID') {
                //     let color = clone_colors(fill.color)
                //     fill.color = invertColor(color)

                //   } else if (fill.type === 'GRADIENT_LINEAR') {
                //     console.log('Gradient fill:', fill.gradientStops);
                //   } else if (fill.type === 'IMAGE') {
                //     console.log('Image fill:', fill.imageRef);
                //   }
                //   // Add handling for other fill types as needed
                // });
              // }
              // if (child.type === 'RECTANGLE') {
                // const fills = clone(child.fills);


    // const frame_exist: { value: boolean } = { value: false };
    // const frame = figma.createNodeFromSvg('FRAME');

      // function clone_colors(val: readonly Paint[]) {
  //   let clone: Paint[]
  //   clone = val.slice()
  //   return clone
  // }