// This file holds the main code for plugins. Code in this file has access to
// the *figma document* via the figma global object.
// You can access browser APIs in the <script> tag inside "ui.html" which has a
// full browser environment (See https://www.figma.com/plugin-docs/how-plugins-run).

// Runs this code if the plugin is run in Figma

// Calls to "parent.postMessage" from within the HTML page will trigger this
  // callback. The callback will be passed the "pluginMessage" property of the
  // posted message.

 /*const nodes: SceneNode[] = [];
      for (let i = 0; i < msg.count; i++) {
        const rect = figma.createRectangle();
        rect.x = i * 150;
        rect.fills = [{type: 'SOLID', color: {r: 1, g: 0.5, b: 0}}];
        figma.currentPage.appendChild(rect);
        nodes.push(rect);
      }
      figma.currentPage.selection = nodes;
      figma.viewport.scrollAndZoomIntoView(nodes);*/

 // Make sure to close the plugin when you're done. Otherwise the plugin will
    // keep running, which shows the cancel button at the bottom of the screen.


// Runs this code if the plugin is run in FigJam


<script src=" https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js "></script>

  async function savePng() {
    if (figma.currentPage.selection.length == 0) {
      document.getElementById('popup-save').style.display = 'block'
      // figma.ui.postMessage({ type: 'cant-save' }, { origin: "*" })
    }
    else {
      const imageBytes = await figma.currentPage.selection[0].exportAsync({ format: 'PNG' })
      const imageBlob = new Blob([imageBytes], { type: 'image/png' })
      saveAs(imageBlob, 'file-name.png')
    }
  }

// if (msg.type === 'save') {

    //   if (figma.currentPage.selection.length == 0) {
    //     figma.ui.postMessage({ type: 'cant-save' }, { origin: "*" })
    //   }
    //   else {
    //     const imageBytes = await figma.currentPage.selection[0].exportAsync({ format: 'PNG' })
    //     const imageBlob = new Blob([imageBytes], { type: 'image/png' })
    //     saveAs(imageBlob, 'file-name.png')
    //   }
    // }

    <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js" crossorigin></script>

<script>
  async function savePng() {
    if (figma.currentPage.selection.length == 0) {
      document.getElementById('popup-save').style.display = 'block'
      // figma.ui.postMessage({ type: 'cant-save' }, { origin: "*" })
    }
    else {
      const imageBytes = await figma.currentPage.selection[0].exportAsync({ format: 'PNG' })
      const imageBlob = new Blob([imageBytes], { type: 'image/png' })
      saveAs(imageBlob, 'file-name.png')
    }
  }

 function saveAs(blob, filename) {
    // Create an anchor element
    let elem = window.document.createElement('a');

    // Set the anchor element's href attribute to a URL representing the Blob object
    elem.href = window.URL.createObjectURL(blob);

    // Set the anchor element's download attribute to the desired file name
    elem.download = filename;

    // Optional: Set some styles to hide the anchor element
    // elem.setAttribute('style', 'display:none;opacity:0;color:transparent;')

    // Append the anchor element to the body of the current document
    (document.body || document.documentElement).appendChild(elem);

    // If the anchor element has a click function, call it
    if (typeof elem.click === 'function') {
      elem.click();
    }
    // If not, dispatch a mouse event with the type 'click'
    else {
      elem.target = '_blank';
      elem.dispatchEvent(new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true
      }));
    }

    // Revoke the object URL created earlier
    URL.revokeObjectURL(elem.href);

    /* Once the object URL is no longer needed, it is a good idea to revoke it to avoid using up
    unnecessary memory and resources. This is especially important in situations where you are 
    creating and revoking many object URLs in a short period of time, as is the case in this code. */

  }

   // if(figma.currentPage.children.includes(comps[i]))
    // {

    //   // figma.currentPage.children.
    // }


          // console.log(comps.length)
          //comp.name= comps.length.toString();
          //figma.currentPage.appendChild(comp);

.figma-light body {
    background-color: white;
    color: blue;
  }
  
  .figma-dark body {
    background-color: black;
    color: red;
  }

  // ef.type='LAYER-BLUR'
      // ef.type = 
      // figma.currentPage.selection[0].
      // let layers = figma.currentPage.selection
      // figma.createEffectStyle

  
/*export const invertImage = async (node: ImagePaint) => {
      const newFills = [];
    
      const image = figma.getImageByHash(node.imageHash);
      const bytes = await image.getBytesAsync();
    
      figma.showUI(__html__, { visible: false });
    
      figma.ui.postMessage({ type: 'invert-image', data: { bytes } });
    
      const newBytes: Uint8Array = await new Promise((resolve) => {
        figma.ui.onmessage = (
          message: MessageEvent & { data: { bytes: Uint8Array } }
        ) => {
          // console.log({ message });
          if (message.type === 'invert-image') {
            resolve(message.data.bytes);
          }
        };
      });
    
      const newPaint = JSON.parse(JSON.stringify(node));
    
      newPaint.imageHash = figma.createImage(newBytes).hash;
      newFills.push(newPaint);
    
      return newFills;
    };*/

// let color :RGB = {r:fill.gradientTransform[0][0], g:fill.gradientTransform[0][1], b:fill.gradientTransform[0][2]}
// let color2: RGB = { r: fill.gradientTransform[1][0], g: fill.gradientTransform[1][1], b: fill.gradientTransform[1][2] }
// let color: RGB = { r: fill.gradientStops[1].color.r, g: fill.gradientTransform[0][1], b: fill.gradientTransform[0][2] }
                   
  // }
              //  if (child.type === 'ELLIPSE' || child.type === 'LINE'
              //    || child.type === 'POLYGON' || child.type === 'STAR' || child.type === 'TEXT') {
              //     child.fills

              // }

  // if (child.type === 'VECTOR') {
              //   const fills = clone(child.fills);
                // fills.forEach((fill) => {
                //   if (fill.type === 'SOLID') {
                //     let color = clone_colors(fill.color)
                //     fill.color = invertColor(color)

                //   } else if (fill.type === 'GRADIENT_LINEAR') {
                //     console.log('Gradient fill:', fill.gradientStops);
                //   } else if (fill.type === 'IMAGE') {
                //     console.log('Image fill:', fill.imageRef);
                //   }
                //   // Add handling for other fill types as needed
                // });
              // }
              // if (child.type === 'RECTANGLE') {
                // const fills = clone(child.fills);


    // const frame_exist: { value: boolean } = { value: false };
    // const frame = figma.createNodeFromSvg('FRAME');

      // function clone_colors(val: readonly Paint[]) {
  //   let clone: Paint[]
  //   clone = val.slice()
  //   return clone
  // }


    // if (msg.type === 'merge') {
    //   let layers: SceneNode[] = clone(figma.currentPage.selection)
    //   if (figma.currentPage.selection.length < 2) { // figma.ui.postMessage({ type: 'not-selected'}, );
    //     figma.ui.postMessage({ type: 'not-selected' }, { origin: "*" })
    //   }
    //   else {
    //     for (let i = 0; i < figma.currentPage.selection.length - 1; i++) {
    //       if (parseInt(figma.currentPage.selection[i].name) > parseInt(figma.currentPage.selection[i++].name) && figma.currentPage.selection[i].type === 'COMPONENT' && figma.currentPage.selection[i++].type === 'COMPONENT')
    //       //proverqvame koe e po golemiq sloi (po golemiq se maha) i dali i 2te izbrani sa component (demek tova koeto polzvam za sloi)
    //       {
    //         let kids: SceneNode[] = clone((figma.currentPage.selection[i] as ComponentNode).children);
    //         for (let j = 0; j < kids.length; j++) {
    //           (figma.currentPage.selection[i++] as ComponentNode).appendChild(kids[j])
    //         }
    //         //prisuedinqvame decatana po-golemiq sloi v malkiq sloi
    //         figma.flatten((figma.currentPage.selection[i++] as ComponentNode).children)
    //         figma.currentPage.selection[i].remove //mahame po golemiq sloi, 4iito deca ve4e trqbwa da sa w drugiq sloi
    //       }
    //       else {
    //         //su6toto no ako i++ e po golqmo
    //         let kids: SceneNode[] = clone((figma.currentPage.selection[i++] as ComponentNode).children);
    //         for (let j = 0; j < kids.length; j++) {
    //           (figma.currentPage.selection[i] as ComponentNode).appendChild(kids[j])
    //         }
    //         figma.flatten((figma.currentPage.selection[i] as ComponentNode).children)
    //         figma.currentPage.selection[i++].remove
    //       }
    //     }
    //   }
    // }


                      // fill.gradientStops = stop
                      // fills[index]=fill
                      // child.fills = fills

  
                // fills=fills as Mutable<Paint>[]
                // fills.forEach((fill,index) => {
                //   fill = fill as Mutable<Paint>
                  
                  
                // }
                // );

 fill.gradientStops.map((gradFill)=>{
                        let stop = (clone_colorStop(gradFill) as Mutable<ColorStop>)
                        let color = (invertColor(stop.color) as Mutable<RGB>)
                        color = invertColor(color)
                        let colorRGBA: RGBA = { r: color.r, b: color.b, g: color.g, a: stop.color.a }
  
                        stop.color = colorRGBA
    return stop
 })


  // function clone_colorStop(val: readonly ColorStop[]) {
  //   let c = val.slice()
  //   return c
  // }

  color = invertColor(color)
                      let colorRGBA: RGBA = { r: color.r, b: color.b, g: color.g, a: stop.color.a }

                      stop.color = colorRGBA

 for (let i = 0; i < fill.gradientStops.length; i++) {
 }




    //     function hexToRgbA(hex) {
    //         var bigint = parseInt(hex.substring(1), 16);
    //         var r = (bigint >> 16) & 255;
    //         var g = (bigint >> 8) & 255;
    //         var b = bigint & 255;
    //         return [r, g, b, 255]; // Alpha is set to 255 (fully opaque)
    //     }